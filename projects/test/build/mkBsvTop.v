//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue May 19 23:25:46 PDT 2020
//
//
// Ports:
// Name                         I/O  size props
// blue                           O     1 const
// green                          O     1 const
// red                            O     1 const
// serial_txd                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// serial_rxd                     I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBsvTop(CLK,
		RST_N,

		blue,

		green,

		red,

		serial_txd,

		serial_rxd);
  input  CLK;
  input  RST_N;

  // value method blue
  output blue;

  // value method green
  output green;

  // value method red
  output red;

  // value method serial_txd
  output serial_txd;

  // action method serial_rx
  input  serial_rxd;

  // signals for module outputs
  wire blue, green, red, serial_txd;

  // register hwmain_ram_inCnt
  reg [1 : 0] hwmain_ram_inCnt;
  wire [1 : 0] hwmain_ram_inCnt_D_IN;
  wire hwmain_ram_inCnt_EN;

  // register hwmain_ram_outCnt
  reg [1 : 0] hwmain_ram_outCnt;
  wire [1 : 0] hwmain_ram_outCnt_D_IN;
  wire hwmain_ram_outCnt_EN;

  // register hwmain_ram_readCnt
  reg [1 : 0] hwmain_ram_readCnt;
  wire [1 : 0] hwmain_ram_readCnt_D_IN;
  wire hwmain_ram_readCnt_EN;

  // register uart_bleft
  reg [3 : 0] uart_bleft;
  wire [3 : 0] uart_bleft_D_IN;
  wire uart_bleft_EN;

  // register uart_clkcnt
  reg [15 : 0] uart_clkcnt;
  wire [15 : 0] uart_clkcnt_D_IN;
  wire uart_clkcnt_EN;

  // register uart_curoutd
  reg [10 : 0] uart_curoutd;
  wire [10 : 0] uart_curoutd_D_IN;
  wire uart_curoutd_EN;

  // register uart_curoutoff
  reg [4 : 0] uart_curoutoff;
  wire [4 : 0] uart_curoutoff_D_IN;
  wire uart_curoutoff_EN;

  // register uart_outword
  reg [7 : 0] uart_outword;
  wire [7 : 0] uart_outword_D_IN;
  wire uart_outword_EN;

  // register uart_rxin
  reg [3 : 0] uart_rxin;
  wire [3 : 0] uart_rxin_D_IN;
  wire uart_rxin_EN;

  // register uart_samplecountdown
  reg [15 : 0] uart_samplecountdown;
  wire [15 : 0] uart_samplecountdown_D_IN;
  wire uart_samplecountdown_EN;

  // register uart_txdr
  reg uart_txdr;
  wire uart_txdr_D_IN, uart_txdr_EN;

  // ports of submodule hwmain_ram_outQ
  wire [15 : 0] hwmain_ram_outQ_D_IN, hwmain_ram_outQ_D_OUT;
  wire hwmain_ram_outQ_CLR,
       hwmain_ram_outQ_DEQ,
       hwmain_ram_outQ_EMPTY_N,
       hwmain_ram_outQ_ENQ,
       hwmain_ram_outQ_FULL_N;

  // ports of submodule hwmain_ram_ram
  wire [15 : 0] hwmain_ram_ram_DATAIN, hwmain_ram_ram_DATAOUT;
  wire [13 : 0] hwmain_ram_ram_ADDRESS;
  wire [3 : 0] hwmain_ram_ram_MASKWREN;
  wire hwmain_ram_ram_CHIPSELECT,
       hwmain_ram_ram_POWEROFF,
       hwmain_ram_ram_SLEEP,
       hwmain_ram_ram_STANDBY,
       hwmain_ram_ram_WREN;

  // ports of submodule hwmain_relayUart
  wire [7 : 0] hwmain_relayUart_D_IN, hwmain_relayUart_D_OUT;
  wire hwmain_relayUart_CLR,
       hwmain_relayUart_DEQ,
       hwmain_relayUart_EMPTY_N,
       hwmain_relayUart_ENQ,
       hwmain_relayUart_FULL_N;

  // ports of submodule uart_outQ
  wire [7 : 0] uart_outQ_D_IN, uart_outQ_D_OUT;
  wire uart_outQ_CLR,
       uart_outQ_DEQ,
       uart_outQ_EMPTY_N,
       uart_outQ_ENQ,
       uart_outQ_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_hwmain_ttt,
       WILL_FIRE_RL_relayUartIn,
       WILL_FIRE_RL_relayUartOut,
       WILL_FIRE_RL_uart_insample;

  // inputs to muxes for submodule ports
  wire [10 : 0] MUX_uart_curoutd_write_1__VAL_1,
		MUX_uart_curoutd_write_1__VAL_2;
  wire [4 : 0] MUX_uart_curoutoff_write_1__VAL_1;
  wire MUX_hwmain_relayUart_enq_1__SEL_2, MUX_uart_curoutd_write_1__SEL_1;

  // remaining internal signals
  wire [15 : 0] data__h1957, x__h369, x__h797;
  wire [3 : 0] x__h949;
  wire uart_clkcnt_PLUS_1_ULT_1250___d3;

  // value method blue
  assign blue = 1'd0 ;

  // value method green
  assign green = 1'd0 ;

  // value method red
  assign red = 1'd0 ;

  // value method serial_txd
  assign serial_txd = uart_txdr ;

  // submodule hwmain_ram_outQ
  FIFO2 #(.width(32'd16), .guarded(32'd1)) hwmain_ram_outQ(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(hwmain_ram_outQ_D_IN),
							   .ENQ(hwmain_ram_outQ_ENQ),
							   .DEQ(hwmain_ram_outQ_DEQ),
							   .CLR(hwmain_ram_outQ_CLR),
							   .D_OUT(hwmain_ram_outQ_D_OUT),
							   .FULL_N(hwmain_ram_outQ_FULL_N),
							   .EMPTY_N(hwmain_ram_outQ_EMPTY_N));

  // submodule hwmain_ram_ram
  SB_SPRAM256KA hwmain_ram_ram(.CLOCK(CLK),
			       .ADDRESS(hwmain_ram_ram_ADDRESS),
			       .CHIPSELECT(hwmain_ram_ram_CHIPSELECT),
			       .DATAIN(hwmain_ram_ram_DATAIN),
			       .MASKWREN(hwmain_ram_ram_MASKWREN),
			       .POWEROFF(hwmain_ram_ram_POWEROFF),
			       .SLEEP(hwmain_ram_ram_SLEEP),
			       .STANDBY(hwmain_ram_ram_STANDBY),
			       .WREN(hwmain_ram_ram_WREN),
			       .DATAOUT(hwmain_ram_ram_DATAOUT));

  // submodule hwmain_relayUart
  FIFO2 #(.width(32'd8), .guarded(32'd1)) hwmain_relayUart(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(hwmain_relayUart_D_IN),
							   .ENQ(hwmain_relayUart_ENQ),
							   .DEQ(hwmain_relayUart_DEQ),
							   .CLR(hwmain_relayUart_CLR),
							   .D_OUT(hwmain_relayUart_D_OUT),
							   .FULL_N(hwmain_relayUart_FULL_N),
							   .EMPTY_N(hwmain_relayUart_EMPTY_N));

  // submodule uart_outQ
  FIFO2 #(.width(32'd8), .guarded(32'd1)) uart_outQ(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(uart_outQ_D_IN),
						    .ENQ(uart_outQ_ENQ),
						    .DEQ(uart_outQ_DEQ),
						    .CLR(uart_outQ_CLR),
						    .D_OUT(uart_outQ_D_OUT),
						    .FULL_N(uart_outQ_FULL_N),
						    .EMPTY_N(uart_outQ_EMPTY_N));

  // rule RL_relayUartOut
  assign WILL_FIRE_RL_relayUartOut =
	     uart_curoutoff == 5'd0 && hwmain_relayUart_EMPTY_N ;

  // rule RL_uart_insample
  assign WILL_FIRE_RL_uart_insample =
	     uart_samplecountdown != 16'd0 || uart_bleft != 4'd1 ||
	     uart_outQ_FULL_N ;

  // rule RL_hwmain_ttt
  assign CAN_FIRE_RL_hwmain_ttt =
	     hwmain_ram_outQ_EMPTY_N && hwmain_relayUart_FULL_N ;

  // rule RL_relayUartIn
  assign WILL_FIRE_RL_relayUartIn =
	     hwmain_ram_inCnt - hwmain_ram_outCnt < 2'd2 &&
	     hwmain_relayUart_FULL_N &&
	     uart_outQ_EMPTY_N ;

  // inputs to muxes for submodule ports
  assign MUX_hwmain_relayUart_enq_1__SEL_2 =
	     CAN_FIRE_RL_hwmain_ttt && !WILL_FIRE_RL_relayUartIn ;
  assign MUX_uart_curoutd_write_1__SEL_1 =
	     !WILL_FIRE_RL_relayUartOut &&
	     !uart_clkcnt_PLUS_1_ULT_1250___d3 &&
	     uart_curoutoff != 5'd0 ;
  assign MUX_uart_curoutd_write_1__VAL_1 = { 1'd1, uart_curoutd[10:1] } ;
  assign MUX_uart_curoutd_write_1__VAL_2 =
	     { 2'b11, hwmain_relayUart_D_OUT, 1'b0 } ;
  assign MUX_uart_curoutoff_write_1__VAL_1 = uart_curoutoff - 5'd1 ;

  // register hwmain_ram_inCnt
  assign hwmain_ram_inCnt_D_IN = hwmain_ram_inCnt + 2'd1 ;
  assign hwmain_ram_inCnt_EN =
	     WILL_FIRE_RL_relayUartIn && !uart_outQ_D_OUT[0] ;

  // register hwmain_ram_outCnt
  assign hwmain_ram_outCnt_D_IN = hwmain_ram_outCnt + 2'd1 ;
  assign hwmain_ram_outCnt_EN = MUX_hwmain_relayUart_enq_1__SEL_2 ;

  // register hwmain_ram_readCnt
  assign hwmain_ram_readCnt_D_IN = hwmain_ram_readCnt + 2'd1 ;
  assign hwmain_ram_readCnt_EN =
	     hwmain_ram_outQ_FULL_N &&
	     hwmain_ram_inCnt - hwmain_ram_readCnt != 2'd0 ;

  // register uart_bleft
  assign uart_bleft_D_IN =
	     (uart_bleft == 4'd0 && !(uart_rxin != 4'd0)) ? 4'd9 : x__h949 ;
  assign uart_bleft_EN =
	     WILL_FIRE_RL_uart_insample &&
	     (uart_bleft == 4'd0 && !(uart_rxin != 4'd0) ||
	      uart_bleft != 4'd0 && uart_samplecountdown == 16'd0) ;

  // register uart_clkcnt
  assign uart_clkcnt_D_IN =
	     uart_clkcnt_PLUS_1_ULT_1250___d3 ? x__h369 : 16'd0 ;
  assign uart_clkcnt_EN = !WILL_FIRE_RL_relayUartOut ;

  // register uart_curoutd
  assign uart_curoutd_D_IN =
	     MUX_uart_curoutd_write_1__SEL_1 ?
	       MUX_uart_curoutd_write_1__VAL_1 :
	       MUX_uart_curoutd_write_1__VAL_2 ;
  assign uart_curoutd_EN =
	     !WILL_FIRE_RL_relayUartOut &&
	     !uart_clkcnt_PLUS_1_ULT_1250___d3 &&
	     uart_curoutoff != 5'd0 ||
	     WILL_FIRE_RL_relayUartOut ;

  // register uart_curoutoff
  assign uart_curoutoff_D_IN =
	     MUX_uart_curoutd_write_1__SEL_1 ?
	       MUX_uart_curoutoff_write_1__VAL_1 :
	       5'd11 ;
  assign uart_curoutoff_EN =
	     !WILL_FIRE_RL_relayUartOut &&
	     !uart_clkcnt_PLUS_1_ULT_1250___d3 &&
	     uart_curoutoff != 5'd0 ||
	     WILL_FIRE_RL_relayUartOut ;

  // register uart_outword
  assign uart_outword_D_IN = { uart_rxin != 4'd0, uart_outword[7:1] } ;
  assign uart_outword_EN =
	     WILL_FIRE_RL_uart_insample && uart_bleft != 4'd0 &&
	     uart_samplecountdown == 16'd0 ;

  // register uart_rxin
  assign uart_rxin_D_IN = { serial_rxd, uart_rxin[3:1] } ;
  assign uart_rxin_EN = 1'd1 ;

  // register uart_samplecountdown
  assign uart_samplecountdown_D_IN =
	     (uart_bleft == 4'd0 && !(uart_rxin != 4'd0)) ?
	       16'd1875 :
	       ((uart_samplecountdown == 16'd0) ? 16'd1250 : x__h797) ;
  assign uart_samplecountdown_EN =
	     WILL_FIRE_RL_uart_insample &&
	     (!(uart_rxin != 4'd0) || uart_bleft != 4'd0) ;

  // register uart_txdr
  assign uart_txdr_D_IN = uart_curoutd[0] ;
  assign uart_txdr_EN = MUX_uart_curoutd_write_1__SEL_1 ;

  // submodule hwmain_ram_outQ
  assign hwmain_ram_outQ_D_IN = hwmain_ram_ram_DATAOUT ;
  assign hwmain_ram_outQ_ENQ =
	     hwmain_ram_outQ_FULL_N &&
	     hwmain_ram_inCnt - hwmain_ram_readCnt != 2'd0 ;
  assign hwmain_ram_outQ_DEQ = MUX_hwmain_relayUart_enq_1__SEL_2 ;
  assign hwmain_ram_outQ_CLR = 1'b0 ;

  // submodule hwmain_ram_ram
  assign hwmain_ram_ram_ADDRESS = { 7'd0, uart_outQ_D_OUT[7:1] } ;
  assign hwmain_ram_ram_CHIPSELECT = 1'd1 ;
  assign hwmain_ram_ram_DATAIN =
	     uart_outQ_D_OUT[0] ? data__h1957 : { 8'd0, uart_outQ_D_OUT } ;
  assign hwmain_ram_ram_MASKWREN = 4'b1111 ;
  assign hwmain_ram_ram_POWEROFF = 1'd1 ;
  assign hwmain_ram_ram_SLEEP = 1'd0 ;
  assign hwmain_ram_ram_STANDBY = 1'd0 ;
  assign hwmain_ram_ram_WREN = uart_outQ_D_OUT[0] ;

  // submodule hwmain_relayUart
  assign hwmain_relayUart_D_IN =
	     WILL_FIRE_RL_relayUartIn ?
	       uart_outQ_D_OUT :
	       hwmain_ram_outQ_D_OUT[7:0] ;
  assign hwmain_relayUart_ENQ =
	     WILL_FIRE_RL_relayUartIn ||
	     CAN_FIRE_RL_hwmain_ttt && !WILL_FIRE_RL_relayUartIn ;
  assign hwmain_relayUart_DEQ = WILL_FIRE_RL_relayUartOut ;
  assign hwmain_relayUart_CLR = 1'b0 ;

  // submodule uart_outQ
  assign uart_outQ_D_IN = uart_outword ;
  assign uart_outQ_ENQ =
	     WILL_FIRE_RL_uart_insample && uart_samplecountdown == 16'd0 &&
	     uart_bleft == 4'd1 ;
  assign uart_outQ_DEQ = WILL_FIRE_RL_relayUartIn ;
  assign uart_outQ_CLR = 1'b0 ;

  // remaining internal signals
  assign data__h1957 = { 8'd0, uart_outQ_D_OUT } ;
  assign uart_clkcnt_PLUS_1_ULT_1250___d3 = x__h369 < 16'd1250 ;
  assign x__h369 = uart_clkcnt + 16'd1 ;
  assign x__h797 = uart_samplecountdown - 16'd1 ;
  assign x__h949 = uart_bleft - 4'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        hwmain_ram_inCnt <= `BSV_ASSIGNMENT_DELAY 2'd0;
	hwmain_ram_outCnt <= `BSV_ASSIGNMENT_DELAY 2'd0;
	hwmain_ram_readCnt <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_bleft <= `BSV_ASSIGNMENT_DELAY 4'd0;
	uart_clkcnt <= `BSV_ASSIGNMENT_DELAY 16'd0;
	uart_curoutd <= `BSV_ASSIGNMENT_DELAY 11'd0;
	uart_curoutoff <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_outword <= `BSV_ASSIGNMENT_DELAY 8'd0;
	uart_rxin <= `BSV_ASSIGNMENT_DELAY 4'b1111;
	uart_samplecountdown <= `BSV_ASSIGNMENT_DELAY 16'd0;
	uart_txdr <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (hwmain_ram_inCnt_EN)
	  hwmain_ram_inCnt <= `BSV_ASSIGNMENT_DELAY hwmain_ram_inCnt_D_IN;
	if (hwmain_ram_outCnt_EN)
	  hwmain_ram_outCnt <= `BSV_ASSIGNMENT_DELAY hwmain_ram_outCnt_D_IN;
	if (hwmain_ram_readCnt_EN)
	  hwmain_ram_readCnt <= `BSV_ASSIGNMENT_DELAY hwmain_ram_readCnt_D_IN;
	if (uart_bleft_EN)
	  uart_bleft <= `BSV_ASSIGNMENT_DELAY uart_bleft_D_IN;
	if (uart_clkcnt_EN)
	  uart_clkcnt <= `BSV_ASSIGNMENT_DELAY uart_clkcnt_D_IN;
	if (uart_curoutd_EN)
	  uart_curoutd <= `BSV_ASSIGNMENT_DELAY uart_curoutd_D_IN;
	if (uart_curoutoff_EN)
	  uart_curoutoff <= `BSV_ASSIGNMENT_DELAY uart_curoutoff_D_IN;
	if (uart_outword_EN)
	  uart_outword <= `BSV_ASSIGNMENT_DELAY uart_outword_D_IN;
	if (uart_rxin_EN) uart_rxin <= `BSV_ASSIGNMENT_DELAY uart_rxin_D_IN;
	if (uart_samplecountdown_EN)
	  uart_samplecountdown <= `BSV_ASSIGNMENT_DELAY
	      uart_samplecountdown_D_IN;
	if (uart_txdr_EN) uart_txdr <= `BSV_ASSIGNMENT_DELAY uart_txdr_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    hwmain_ram_inCnt = 2'h2;
    hwmain_ram_outCnt = 2'h2;
    hwmain_ram_readCnt = 2'h2;
    uart_bleft = 4'hA;
    uart_clkcnt = 16'hAAAA;
    uart_curoutd = 11'h2AA;
    uart_curoutoff = 5'h0A;
    uart_outword = 8'hAA;
    uart_rxin = 4'hA;
    uart_samplecountdown = 16'hAAAA;
    uart_txdr = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_relayUartOut)
	$write("uartOut %d\n", hwmain_relayUart_D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_relayUartIn) $write("uartIn %d\n", uart_outQ_D_OUT);
  end
  // synopsys translate_on
endmodule  // mkBsvTop

